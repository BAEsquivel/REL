{"tagline":"A Regular Expression composition Library","name":"REL","google":"","body":"# REL, a Regular Expression composition Library\r\n\r\nREL is a small utility Scala library for people dealing with complex, modular regular expressions. It defines a DSL with most of the operators you already know and love. This allows you to isolate portions of your regex for easier testing and reuse.\r\n\r\nConsider the following YYYY-MM-DD date regex: `^(?:19|20)\\d\\d([- /.])(?:0[1-9]|1[012])\\1(?:0[1-9]|[12]\\d|3[01])$`. It is a bit more readable and reusable expressed like this:\r\n\r\n```scala\r\nimport fr.splayce.rel._\r\nimport Implicits._\r\n\r\nval sep     = \"[- /.]\" \\ \"sep\"            // group named \"sep\"\r\nval year    = (\"19\" | \"20\") ~ \"\"\"\\d\\d\"\"\"  // ~ is concatenation\r\nval month   = \"0[1-9]\" | \"1[012]\"\r\nval day     = \"0[1-9]\" | \"[12]\\\\d\" | \"3[01]\"\r\nval dateYMD = ^ ~ year  ~ sep ~ month ~ !sep ~ day  ~ $\r\nval dateMDY = ^ ~ month ~ sep ~ day   ~ !sep ~ year ~ $\r\n```\r\n\r\nThese value are `RE` objects (also named _terms_ or _trees_/_subtrees_), which can be converted to `scala.util.matching.Regex` instances either implicitly (by importing `rel.Implicits._`) or explicitly (via the `.r` method).\r\n\r\nThe embedded [Date regexes](https://github.com/Imaginatio/REL/blob/master/src/main/scala/matchers/Date.scala) and [extractors](https://github.com/Imaginatio/REL/blob/master/src/main/scala/matchers/DateExtractor.scala) will give you more complete examples, matching several date formats at once with little prior knowledge.\r\n\r\n### Supported opperators\r\n\r\n> Examples are noted `DSL expression` → `resulting regex`. They assume:\r\n> ```scala\r\nimport fr.splayce.rel._\r\nimport Implicits._\r\nval a = RE(\"aa\")\r\nval b = RE(\"bb\")\r\n```\r\n\r\n- Concatenation:\r\n    - Protected:   `a ~ b` → `(?:aa)(?:bb)`\r\n    - Unprotected: `a - b` → `aabb`\r\n- Alternative: `a | b` → `aa|bb`\r\n- Option:\r\n    - [greedy](http://www.regular-expressions.info/repeat.html#greedy) `a.?` → `(?:aa)?` ; you can also skip the dot `a ?` but the former has clearer priority in a complex expression\r\n    - [reluctant / lazy](http://www.regular-expressions.info/repeat.html#lazy): `a.??` → `(?:aa)??`\r\n    - [possessive](http://www.regular-expressions.info/possessive.html): `a.?+` → `(?:aa)?+`\r\n- Repeat:\r\n    - At least one:\r\n        - greedy:     `a.+`  → `(?:aa)+`\r\n        - reluctant:  `a.+?` → `(?:aa)+?`\r\n        - possessive: `a.++` → `(?:aa)++`\r\n    - Any number:\r\n        - greedy:     `a.*`  → `(?:aa)*`\r\n        - reluctant:  `a.*?` → `(?:aa)*?`\r\n        - possessive: `a.*+` → `(?:aa)*+`\r\n    - In range:\r\n        - greedy:     `a(1,3)` or `a(1 to 3)` or `a(1 -> 3)` → `(?:aa){1,3}`\r\n        - reluctant:  `a(1, 3, Reluctant)`  → `(?:aa){1,3}?`\r\n        - possessive: `a(1, 3, Possessive)` → `(?:aa){1,3}+`\r\n    - At most:\r\n        - greedy:     `a < 3`   → `(?:aa){0,3}`\r\n        - reluctant:  `a.<?(3)` → `(?:aa){0,3}?` (dotted form `a.<?(3)` is mandatory, standalone `<?` being syntactically significant in Scala: `XMLSTART`)\r\n        - possessive: `a <+ 3`  → `(?:aa){0,3}+`\r\n    - At least:\r\n        - greedy:     `a > 3`  → `(?:aa){3,}`\r\n        - reluctant:  `a >? 3` → `(?:aa){3,}?`\r\n        - possessive: `a >+ 3` → `(?:aa){3,}+`\r\n    - Exactly: `a{3}` or `a(3)` → `(?:aa){3}`\r\n- Lookaround:\r\n    - Lookahead:           `?=(a)`  or `a.?=`  → `(?=aa)`\r\n    - Lookbehind:          `?<=(a)` or `a.?<=` → `(?<=aa)`\r\n    - Negative lookahead:  `?!(a)`  or `a.?!`  → `(?!aa)`\r\n    - Negative lookbehind: `?<!(a)` or `a.?<!` → `(?<!aa)`\r\n- Grouping:\r\n    - Named: `a \\ \"group_a\"` → `(aa)`; the name `group_a` will be passed to the `Regex` constructor,  queryable on corresponding `Match`es\r\n    - Unnamed: `a.g` → `(aa)` (a unique group name is generated internally)\r\n    - Non-capturing: `a.ncg` → `(?:aa)` or the short syntax `a.%`; will try not to uselessly wrap non-breaking entities (i.e. single letters like `a` or `\\u00F0` and character classes like `\\w`, `[^a-z]` or `\\p{Lu}`) to produce ever-so-slightly less unreadable output\r\n    - [Atomic](http://www.regular-expressions.info/atomic.html): `a.ag` → `(?>aa)` or the short syntaxes `?>(a)` and `a.?>`\r\n- Back-reference: `!g` will insert a backreference on group `g`; e.g. `val g = (a|b).g; g - a - !g` → `(aa|bb)aa\\1`\r\n\r\n### Constants\r\n\r\nA few \"constants\" (expression terms with no repetitions, capturing groups, or unprotected alternatives) are also pre-defined. Some of them have a UTF-8 Greek symbol alias for conciseness (import `rel.Symbols._` to use them), uppercase for negation. You can add your own by instancing case class `RECst(expr)`\r\n\r\n- `Epsilon` or `ε` → empty string\r\n- `Dot` or `τ` → `.`,          `LineTerminator` or `Τ`* → `(?:\\r\\n?|[\\n\\u0085\\u2028\\u2029])` ([line terminators](http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#lt))\r\n- `MLDot` or `ττ` → `[\\s\\S]` (will match any char, including line terminators, even when the [`DOTALL`](http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#DOTALL) or [`MULTILINE`](http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#MULTILINE) modes are disabled)\r\n- `AlphaLower` → `[a-z]`,      `AlphaUpper` → `[A-Z]`\r\n- `Alpha` or `α` → `[a-zA-Z]`, `NotAlpha` or `Α`* → `[^a-zA-Z]`\r\n- `LetterLower` → `\\p{Ll}`,    `LetterUpper` → `\\p{Lu}` (unicode letters, including diacritics)\r\n- `Letter` or `λ` → `\\p{L}`,   `NotLetter` or `Λ` → `\\P{L}`\r\n- `Digit` or `δ` → `\\d`,       `NotDigit` or `Δ` → `\\D`\r\n- `WhiteSpace` or `σ` → `\\s`,  `NotWhiteSpace` or `Σ` → `\\S`\r\n- `Word` or `μ` → `\\w` (`Alpha` or `_`), `NotWord` or `Μ`* → `\\W`\r\n- `WordBoundary` or `ß` → `\\b`, `NotWordBoundary` or `Β`* → `\\B`\r\n- `LineBegin` or `^` → `^`,     `LineEnd` or `$` → `$`\r\n- `InputBegin` or `^^` → `\\A`,  `InputEnd` or `$$` → `\\z`\r\n\r\n_\\* Those are uppercase `α`/`ß`/`μ`/`τ`, not latin `A`/`B`/`M`/`T`_\r\n\r\n### Exporting regexes (and other regex flavors)\r\n\r\nThe `.r` method on any `RE` term returns a compiled `scala.util.matching.Regex`. The `.toString` method returns the source pattern (equivalent to `.r.toString`, so the pattern is verified).\r\n\r\nFor other regex flavors, a translation mechanism is provided: you may instanciate a [`Flavor`](https://github.com/Imaginatio/REL/blob/master/src/main/scala/util/Flavor.scala), which exposes two methods: `.express(re: RE)` and `.translate(re: RE)`. The first one returns a `Tuple2[String, List[String]]`, whose first element is the translated regex string and whose second is a list of the group names (in order of appearance) allowing you to perform a mapping to capturing group indexes (like Scala does) if needed. The second method only performs the translation of a `RE` term into another.\r\n\r\nAn example of translation into [.NET-flavored regex](http://www.regular-expressions.info/dotnet.html) is provided. [`DotNETTranslator`](https://github.com/Imaginatio/REL/blob/master/src/main/scala/flavors/DotNETTranslator.scala) contains the actual translation, `DotNETFlavor` being declared in the [`flavors` package object](https://github.com/Imaginatio/REL/blob/master/src/main/scala/flavors/package.scala). The translation:\r\n\r\n- changes `\\w` to `[a-zA-Z0-9_]` (when used with `Word`/`μ`), since .NET's `\\w` covers UTF-8 letters including accented, while Java's covers only ASCII\r\n- turns any possessive quantifier into a greedy quantifier wrapped in an atomic group (which is a longer equivalent)\r\n- inlines named groups and their references into the .NET `(?<name>expr)` syntax\r\n\r\nAnother example is the [`JavaScriptTranslator`](https://github.com/Imaginatio/REL/blob/master/src/main/scala/flavors/JavaScriptTranslator.scala), which will mainly throw an exception when you try to translate a `RE` term that is not supported in the [JavaScript regex flavor](http://www.regular-expressions.info/javascript.html).\r\n\r\n[Regular-expression.info](http://www.regular-expressions.info)'s [regex flavors comparison chart](http://www.regular-expressions.info/refflavors.html) may be of use when writing a translation.\r\n\r\n### Capturing Groups\r\n\r\nSince a REL term is a tree, it can compute the resulting capturing groups tree with the `matchGroup` val, containing a tree of `MatchGroup`s. The top group corresponds to the entire match: it is unnamed, contains the matched content and has the first-level capturing groups nested as subgroups. When applied to a `Match`, the content of each group is filled. Thus, you can use pattern matching with nested groups to extract any group at several levels of imbrication with little code.\r\n\r\nFor example, let's say we want to match simple usernames that have the form `user@machine` where both part have only alphabetic characters. We can define the regex:\r\n\r\n```scala\r\nval user     = α.+ \\ \"user\"\r\nval at       = \"@\"\r\nval machine  = α.+ \\ \"machine\"\r\nval username = (user - at - machine) \\ \"username\"\r\n```\r\n\r\nAnd make a simple extractor that yields a tuple of Strings:\r\n\r\n```scala\r\nval userMatcher: PartialFunction[MatchGroup, (String, String)] = {\r\n  case MatchGroup(None, Some(_), List(              // this is the full match ($0)\r\n      MatchGroup(Some(\"username\"), Some(_), List(   // $1 / username\r\n        MatchGroup(Some(\"user\"),    Some(u), Nil),  // $2 / user\r\n        MatchGroup(Some(\"machine\"), Some(m), Nil)   // $3 / machine\r\n      ))\r\n    )) => (u, m)\r\n}\r\n```\r\n\r\nExtraction in a String can be done like this:\r\n\r\n```scala\r\nimport ByOptionExtractor._                    // lift (and toPM on further examples)\r\nval userExtractor = username << lift(userMatcher)\r\nval users = userExtractor(\"me@dev, you@dev\")  // Iterator[(String, String)]\r\nusers.toList.toString === \"List((me,dev), (you,dev))\"\r\n```\r\n\r\nJava does not support named capturing groups, and Scala only emulates them, mapping a list of names given at the compilation of the Regex against the indexes of the capturing groups. Thus, it is risky to have multiple instances of the same group name. In practice, using `myMatch.group(\"myGroup\")` seems to always refer to the last occurrence of the `myGroup`.\r\n\r\nOn the other hand, the `Match` object carries the full list of group names (in its eponymous `groupNames` val), and REL uses it to compute the group tree. Thus, you _can_ reuse the same group name in a single expression.\r\n\r\nSay we want to extract items formatted with `username->username`:\r\n\r\n```scala\r\nval interaction = username - \"->\" - username\r\nval iaMatcher: PartialFunction[MatchGroup, (String, String)] = {\r\n  case MatchGroup(None, Some(_), List(\r\n      MatchGroup(Some(\"username\"), Some(un1), _),\r\n      MatchGroup(Some(\"username\"), Some(un2), _)\r\n    )) => (un1, un2)\r\n}\r\nval iaExtractor = interaction << lift(iaMatcher)\r\nval interactions = iaExtractor(\"me@dev->you@dev, you@dev->me@dev\")\r\ninteractions.toList.toString === \"List((me@dev,you@dev), (you@dev,me@dev))\"\r\n```\r\n\r\nYou can of course reuse the same extractor, which can directly provide the extracted object. This requires us to place the extractor one level deeper to avoid the `$0` group:\r\n\r\n```scala\r\nval userMatcher2: PartialFunction[MatchGroup, (String, String)] = {\r\n  case MatchGroup(Some(\"username\"), Some(_), List(\r\n        MatchGroup(Some(\"user\"),    Some(u), Nil),\r\n        MatchGroup(Some(\"machine\"), Some(m), Nil)\r\n    )) => (u, m)\r\n}\r\nval userPattern = toPM(lift(userMatcher2))\r\nval iaMatcher2: PartialFunction[MatchGroup, (String, String, String, String)] = {\r\n  case MatchGroup(None, Some(_), List(\r\n      userPattern(u1, m1),\r\n      userPattern(u2, m2)\r\n    )) => (u1, m1, u2, m2)\r\n}\r\nval iaExtractor2 = interaction << lift(iaMatcher2)\r\nval interactions2 = iaExtractor2(\"me@dev->you@dev, you@dev->me@dev\")\r\ninteractions2.toList.toString === \"List((me,dev,you,dev), (you,dev,me,dev))\"\r\n```\r\n\r\n\r\n## TODO\r\n\r\n- Core\r\n    - Add character range support (at DSL level), with inversion (`[^...]`)\r\n    - Compatibility with Scala Parsers?\r\n    - Consider using `'symbols` for group names\r\n    - Support regex [compilation flags](http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#field_summary). Add options to easily embed match flags`(?idmsux-idmsux)` when generating regex.\r\n    - Parse \\[and limit] regex strings inputted to REL, producing REL-only expression trees, thus eliminating some known issues (see below) and opening some possibilities (e.g. generating sample matching strings)\r\n- Matchers\r\n    - date: consider extracting incorrect dates (like feb. 31st) with some flag\r\n- Utils\r\n    - Generate sample strings that match a regex (e.g. with [Xeger](http://code.google.com/p/xeger/))\r\n    - Source generation or compiler plugin to enable REL independance \\[at runtime]\r\n    - Binary tool that would take a REL file, compile it and produce regexes in several flavors / programming langagues\r\n- Documentation\r\n    - Document cleaners, extractors, matchers\r\n    - Make the present document a simple description and split the documentation part into several linked pages: syntax, matchers, extractors, flavors…\r\n\r\n\r\n## Known issues\r\n\r\n### Versionning\r\n\r\nREL version number follows the [Semantic Versionning 2.0 Specification](http://semver.org/). In the current early stage of development, the API is still unstable and backward compatibility may break.\r\nHowever, in version (0.Y.Z), a Z-only version is expected to be backard compatible with previous 0.Y.* version. But a Y version change poteantially breaks backward compatibility.\r\n\r\n### String primitives\r\n\r\nThe string primitives are not parsed (use `esc(str)` to escape a string that should be matched literally). Hence:\r\n\r\n- Any capturing group you pass inside those strings won't be taken into account by REL when the final regex is generated. The following groups and back-references will be shifted so the resulting regex will most probably be incorrect.\r\n- You still need to escape your expressions to match literally characters that are regex-significant like `+`, `?` or `(`, even in `RECst`. Use `esc(str)` to escape the whole string.\r\n- Any regex you pass as a string will be kept as-is when translated into different flavors. For instance, the `\\w` passed in a string (as opposed to used with `Word`/`μ`) will not be translated by the `DotNETTranslator`.\r\n\r\n### Flavors\r\n\r\nJavaScript regexes are very limited and work a bit differently. In [JavaScript flavor](https://github.com/Imaginatio/REL/blob/master/src/main/scala/flavors/JavaScriptTranslator.scala)\r\n\r\n- `WordBoundary`/`\\b` is kept as-is, but will not have exactly the same semantic because of the lack of Unicode support in JavaScript regex flavor. For instance, in `\"fiancé\"`, Javascript sees `\"\\bfianc\\bé\"` where most other flavors see `\"\\bfiancé\\b\"`. Same goes for `NotWordBoundary`/`\\B`.\r\n- `InputBegin` (`^^`) and `InputEnd` (`$$`) are translated to `LineBegin` (`^`) and `LineEnd` (`$`), but this is only correct if the `m` (multiline) flag is off.\r\n\r\nIn [.NET flavor](https://github.com/Imaginatio/REL/blob/master/src/main/scala/flavors/DotNETTranslator.scala), the group names are not guaranteed to be valid.\r\n\r\n\r\n## Usage and downloads\r\n\r\n- download the [source from github](https://github.com/Imaginatio/REL) and build the library with SBT\r\n- download the [latest binary release](https://github.com/Imaginatio/REL/downloads)\r\n- use [our public Maven repository](https://github.com/Imaginatio/Maven-repository/)\r\n\r\n\r\n## License\r\n\r\nCopyright &copy; 2012 Imaginatio SAS\r\n\r\nREL is released under the [MIT License](http://www.opensource.org/licenses/MIT)\r\n\r\n\r\n## Authors\r\n\r\nREL was developped by [Adrien Lavoillotte](http://instanceof.me/) ([@streetpc](https://github.com/streetpc)) and Julien Martin for project [Splayce](http://splayce.com) at [Imaginatio](http://imaginatio.fr)\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}