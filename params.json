{"tagline":"A Regular Expression composition Library","google":"","body":"# REL, a Regular Expression composition Library\r\n\r\nREL is a small utility Scala library for people dealing with complex, modular regular expressions. It defines a DSL with most of the operators you already know and love. This allows you to isolate portions of your regex for easier testing and reuse.\r\n\r\nConsider the following YYYY-MM-DD date regex: `^(?:19|20)\\d\\d([- /.])(?:0[1-9]|1[012])\\1(?:0[1-9]|[12]\\d|3[01])$`. It is a bit more readable and reusable expressed like this:\r\n\r\n```scala\r\nimport fr.splayce.REL._\r\nimport Implicits._\r\n\r\nval sep     = \"[- /.]\" \\ \"sep\"            // group named \"sep\"\r\nval year    = (\"19\" | \"20\") ~ \"\"\"\\d\\d\"\"\"  // ~ is concatenation\r\nval month   = \"0[1-9]\" | \"1[012]\"\r\nval day     = \"0[1-9]\" | \"[12]\\\\d\" | \"3[01]\"\r\nval dateYMD = \"^\" ~ year  ~ sep ~ month ~ !sep ~ day  ~ \"$\"\r\nval dateMDY = \"^\" ~ month ~ sep ~ day   ~ !sep ~ year ~ \"$\"\r\n```\r\n\r\nThese value are `RE` objects (trees/subtrees), which can be converted to `scala.util.matching.Regex` instances either implicitly (by importing `REL.Implicits._`) or explicitly (via the `.r` method).\r\n\r\nThe embedded [Date regexes](https://github.com/Imaginatio/REL/blob/master/src/main/scala/matchers/Date.scala) and [extractors](https://github.com/Imaginatio/REL/blob/master/src/main/scala/matchers/DateExtractor.scala) will give you more complete examples, matching several date formats at once with little prior knowledge.\r\n\r\n### Supported opperators\r\n\r\n> Examples are noted `DSL expression` → `resulting regex`. They assume:\r\n> ```scala\r\nimport fr.splayce.REL._\r\nimport Implicits._\r\nval a = RE(\"a\")\r\nval b = RE(\"b\")\r\n```\r\n\r\n- Concatenation:\r\n    - Protected: `a ~ b` → `(?:a)(?:b)`\r\n    - Unprotected: `a - b` → `ab`\r\n- Alternative: `a | b` → `a|b`\r\n- Option:\r\n    - [greedy](http://www.regular-expressions.info/repeat.html#greedy) `a.?` → `(?:a)?` ; you can also skip the dot `a ?` but the former has clearer priority in a complex expression\r\n    - [reluctant / lazy](http://www.regular-expressions.info/repeat.html#lazy): `a.??` → `(?:a)??`\r\n    - [possessive](http://www.regular-expressions.info/possessive.html): `a.?+` → `(?:a)?+`\r\n- Repeat:\r\n    - At least one:\r\n        - greedy: `a.+ ` → `(?:a)+`\r\n        - reluctant: `a.+? ` → `(?:a)+?`\r\n        - possessive: `a.++ ` → `(?:a)++`\r\n    - Any number:\r\n        - greedy: `a.* ` → `(?:a)*`\r\n        - reluctant: `a.*? ` → `(?:a)*?`\r\n        - possessive: `a.*+ ` → `(?:a)*+`\r\n    - In range: `a(1,3)` or `a(1 to 3)` → `(?:a){1,}`\r\n    - At most: `a(0,3)` → `(?:a){0,3}` (duh)\r\n    - At least: `a(3)` → `(?:a){3,}`\r\n    - Exactly: `a^3` → `(?:a){3}`\r\n- Lookaround:\r\n    - Lookahead: `a.>?` → `(?=a)`\r\n    - Lookbehind: `a.<?` → `(?<=a)`\r\n    - Negative lookahead: `a.>!` → `(?!a)`\r\n    - Negative lookbehind: `a.<!` → `(?<!a)`\r\n- Grouping:\r\n    - Named: `a \\ \"group_a\"` → `(a)`; the name `group_a` will be passed to the `Regex` constructor,  queryable on corresponding `Match`es\r\n    - Unnamed: `a.g` → `(a)` (a unique group name is generated internally)\r\n    - Non-capturing: `a.ncg` → `(?:a)` or the short syntax `a.%`\r\n    - [Atomic](http://www.regular-expressions.info/atomic.html): `a.ag` → `(?>a)` or the short syntax `a.?>`\r\n- Back-reference: `!g` will insert a backreference on group `g`; e.g. `val g = (a|b).g; g - a - !g` → `(a|b)a\\1`\r\n\r\n### Constants\r\n\r\nA few \"constants\" (sub-expressions with no repetitions, capturing groups, or unprotected alternatives) are also pre-defined. Some of them have a UTF-8 Greek symbol alias for conciseness (import `REL.Symbols._` to use them), uppercase for negation. You can add your own by instancing case class `RECst(expr)`\r\n\r\n- `Epsilon` or `ε` is empty string\r\n- `AlphaLower` → `[a-z]`, `AlphaUpper` → `[A-Z]`\r\n- `Alpha` or `α` → `[a-zA-Z]`, `NotAlpha` or `Α`* → `[^a-zA-Z]`\r\n- `LetterLower` → `\\p{Ll}`, `LetterUpper` → `\\p{Lu}` (unicode letters, including)\r\n- `Letter` or `λ` → `\\p{L}`, `NotLetter` or `Λ` → `\\P{L}`\r\n- `Digit` or `δ` → `\\d`, `NotDigit` or `Δ` → `\\D`\r\n- `WhiteSpace` or `σ` → `\\s`, `NotWhiteSpace` or `Σ` → `\\S`\r\n- `Word` or `μ` → `\\w` (`Alpha` or `_`), `NotWord` or `Μ`* → `\\W`\r\n- `WordBoundary` or `ß` → `\\b`, `NotWordBoundary` or `Β`* → `\\B`\r\n- `LineBeginning` → `^`, `LineEnd` → `$`\r\n- `InputBeginning` → `\\A`, `InputEnd` → `\\z`\r\n\r\n_\\* Those are uppercase `α`/`ß`/`μ`, not latin `A`/`B`/`M`_\r\n\r\n### Exporting regexes (and other regex flavors)\r\n\r\nThe `.r` method on any `RE` (sub)tree returns a compiled `scala.util.matching.Regex`. The `.toString` method returns the source pattern (equivalent to `.r.toString`, so the pattern is verified).\r\n\r\nFor other regex flavors, a translation mechanism is provided: you may subclass `Flavor`, which exposes a `.express(re: RE)` method, returning a `Tuple[String, List[String]]`. The first element is the translated regex string, the second is a list of the group names (in order of appearance). A subclass of `Flavor` should override `.translate(re: RE)`, using pattern matching to recursively translate Java regex subtree with matching subtree in the destination regex Flavor. It should call `super.translate` in the default case to ensure proper recusion.\r\n\r\nAn example of translation into [.NET-flavored regex](http://www.regular-expressions.info/dotnet.html) is provided ([`DotNETFlavor`](https://github.com/Imaginatio/REL/blob/master/src/main/scala/flavors/DotNETFlavor.scala)), that\r\n\r\n- translates `\\w` to `[a-zA-Z0-9_]` (as .NET's `\\w` covers UTF-8 letters including accented, while Java's covers only ASCII)\r\n- turns any possessive quantifier into a greedy quantifier wrapped in an atomic group (which is a longer equivalent)\r\n- inlines named groups and their references into the .NET `(?<name>expr)` syntax\r\n\r\n[Regular-expression.info](http://www.regular-expressions.info)'s [regex flavors comparison chart](http://www.regular-expressions.info/refflavors.html) may be of use when writing a translation.\r\n\r\n\r\n## TODO\r\n\r\n- Core\r\n    - Add `RECst.literal(string)` (aliased by `RE.literal(string)`) for auto-escaped literal sequence ; consider `RE.apply('symbol)` to be another alias\r\n    - Add missing short notation for non-greedy RepMode in numbered Rep\r\n    - Add character range support (at DSL level), with inversion (`[^...]`)\r\n    - Shortcuts for `^` and `$` (beware `^` is currently used as exactly-N repeater operator)\r\n    - Consider using `'symbols` for group names\r\n    - Add options to easily embed match flags`(?idmsux-idmsux)` when generating regex\r\n- Matchers\r\n    - date: consider extracting incorrect dates (like feb. 31st) with some flag\r\n- Utils\r\n    - Generate sample strings that match a regex (e.g. with [Xeger](http://code.google.com/p/xeger/))\r\n    - Source generation or compiler plugin to enable REL independance \\[at runtime]\r\n- Documentation\r\n    - Document cleaners and extractors\r\n\r\n\r\n## Known issues\r\n\r\nThe string primitives are not parsed, so\r\n\r\n- Any group you pass inside those strings won't be taken into account by REL when the final regex is generated. The following groups and back-references will be shifted so the resulting regex will most probably be incorrect.\r\n\r\n- You still need to escape your expressions to match regex-significant characters like `+`, `?` or `(`, even in `RECst` (pending update on this point)\r\n\r\n\r\n## Usage and downloads\r\n\r\n- download the [source from github](https://github.com/Imaginatio/REL) and build the library with SBT\r\n- download the [latest binary release](https://github.com/Imaginatio/REL/downloads)\r\n- use [our public Maven repository](https://github.com/Imaginatio/Maven-repository/)\r\n\r\n\r\n## License\r\n\r\nCopyright &copy; 2012 Imaginatio SAS\r\n\r\nREL is released under the [MIT License](http://www.opensource.org/licenses/MIT)\r\n\r\n\r\n## Authors\r\n\r\nREL was developped by [Adrien Lavoillotte](http://instanceof.me/) ([@streetpc](https://github.com/streetpc)) and Julien Martin for project [Splayce](http://splayce.com) at [Imaginatio](http://imaginatio.fr)\r\n","name":"REL","note":"Don't delete this file! It's used internally to help with page regeneration."}