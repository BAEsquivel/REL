<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>REL by Imaginatio</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>REL</h1>
        <p>A Regular Expression composition Library</p>

        <p class="view"><a href="https://github.com/Imaginatio/REL">View the Project on GitHub <small>Imaginatio/REL</small></a></p>


        <ul>
          <li><a href="https://github.com/Imaginatio/REL/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/Imaginatio/REL/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/Imaginatio/REL">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>REL, a Regular Expression composition Library</h1>

<p>REL is a small utility Scala library for people dealing with complex, modular regular expressions. It defines a DSL with most of the operators you already know and love. This allows you to isolate portions of your regex for easier testing and reuse.</p>

<p>Consider the following YYYY-MM-DD date regex: <code>^(?:19|20)\d\d([- /.])(?:0[1-9]|1[012])\1(?:0[1-9]|[12]\d|3[01])$</code>. It is a bit more readable and reusable expressed like this:</p>

<div class="highlight"><pre><span class="k">import</span> <span class="nn">fr.splayce.REL._</span>
<span class="k">import</span> <span class="nn">Implicits._</span>

<span class="k">val</span> <span class="n">sep</span>     <span class="k">=</span> <span class="s">"[- /.]"</span> <span class="o">\</span> <span class="s">"sep"</span>            <span class="c1">// group named "sep"</span>
<span class="k">val</span> <span class="n">year</span>    <span class="k">=</span> <span class="o">(</span><span class="s">"19"</span> <span class="o">|</span> <span class="s">"20"</span><span class="o">)</span> <span class="o">~</span> <span class="s">"""\d\d"""</span>  <span class="c1">// ~ is concatenation</span>
<span class="k">val</span> <span class="n">month</span>   <span class="k">=</span> <span class="s">"0[1-9]"</span> <span class="o">|</span> <span class="s">"1[012]"</span>
<span class="k">val</span> <span class="n">day</span>     <span class="k">=</span> <span class="s">"0[1-9]"</span> <span class="o">|</span> <span class="s">"[12]\\d"</span> <span class="o">|</span> <span class="s">"3[01]"</span>
<span class="k">val</span> <span class="n">dateYMD</span> <span class="k">=</span> <span class="s">"^"</span> <span class="o">~</span> <span class="n">year</span>  <span class="o">~</span> <span class="n">sep</span> <span class="o">~</span> <span class="n">month</span> <span class="o">~</span> <span class="o">!</span><span class="n">sep</span> <span class="o">~</span> <span class="n">day</span>  <span class="o">~</span> <span class="s">"$"</span>
<span class="k">val</span> <span class="n">dateMDY</span> <span class="k">=</span> <span class="s">"^"</span> <span class="o">~</span> <span class="n">month</span> <span class="o">~</span> <span class="n">sep</span> <span class="o">~</span> <span class="n">day</span>   <span class="o">~</span> <span class="o">!</span><span class="n">sep</span> <span class="o">~</span> <span class="n">year</span> <span class="o">~</span> <span class="s">"$"</span>
</pre></div>

<p>These value are <code>RE</code> objects (trees/subtrees), which can be converted to <code>scala.util.matching.Regex</code> instances either implicitly (by importing <code>REL.Implicits._</code>) or explicitly (via the <code>.r</code> method).</p>

<p>The embedded <a href="https://github.com/Imaginatio/REL/blob/master/src/main/scala/matchers/Date.scala">Date regexes</a> and <a href="https://github.com/Imaginatio/REL/blob/master/src/main/scala/matchers/DateExtractor.scala">extractors</a> will give you more complete examples, matching several date formats at once with little prior knowledge.</p>

<h3>Supported opperators</h3>

<blockquote>
<p>Examples are noted <code>DSL expression</code> → <code>resulting regex</code>. They assume:</p>

<div class="highlight"><pre><span class="k">import</span> <span class="nn">fr.splayce.REL._</span>
<span class="k">import</span> <span class="nn">Implicits._</span>
<span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="nc">RE</span><span class="o">(</span><span class="s">"a"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="nc">RE</span><span class="o">(</span><span class="s">"b"</span><span class="o">)</span>
</pre></div>
</blockquote>

<ul>
<li>Concatenation:

<ul>
<li>Protected: <code>a ~ b</code> → <code>(?:a)(?:b)</code>
</li>
<li>Unprotected: <code>a - b</code> → <code>ab</code>
</li>
</ul>
</li>
<li>Alternative: <code>a | b</code> → <code>a|b</code>
</li>
<li>Option:

<ul>
<li>
<a href="http://www.regular-expressions.info/repeat.html#greedy">greedy</a> <code>a.?</code> → <code>(?:a)?</code> ; you can also skip the dot <code>a ?</code> but the former has clearer priority in a complex expression</li>
<li>
<a href="http://www.regular-expressions.info/repeat.html#lazy">reluctant / lazy</a>: <code>a.??</code> → <code>(?:a)??</code>
</li>
<li>
<a href="http://www.regular-expressions.info/possessive.html">possessive</a>: <code>a.?+</code> → <code>(?:a)?+</code>
</li>
</ul>
</li>
<li>Repeat:

<ul>
<li>At least one:

<ul>
<li>greedy: <code>a.+</code> → <code>(?:a)+</code>
</li>
<li>reluctant: <code>a.+?</code> → <code>(?:a)+?</code>
</li>
<li>possessive: <code>a.++</code> → <code>(?:a)++</code>
</li>
</ul>
</li>
<li>Any number:

<ul>
<li>greedy: <code>a.*</code> → <code>(?:a)*</code>
</li>
<li>reluctant: <code>a.*?</code> → <code>(?:a)*?</code>
</li>
<li>possessive: <code>a.*+</code> → <code>(?:a)*+</code>
</li>
</ul>
</li>
<li>In range: <code>a(1,3)</code> or <code>a(1 to 3)</code> → <code>(?:a){1,}</code>
</li>
<li>At most: <code>a(0,3)</code> → <code>(?:a){0,3}</code> (duh)</li>
<li>At least: <code>a(3)</code> → <code>(?:a){3,}</code>
</li>
<li>Exactly: <code>a^3</code> → <code>(?:a){3}</code>
</li>
</ul>
</li>
<li>Lookaround:

<ul>
<li>Lookahead: <code>a.&gt;?</code> → <code>(?=a)</code>
</li>
<li>Lookbehind: <code>a.&lt;?</code> → <code>(?&lt;=a)</code>
</li>
<li>Negative lookahead: <code>a.&gt;!</code> → <code>(?!a)</code>
</li>
<li>Negative lookbehind: <code>a.&lt;!</code> → <code>(?&lt;!a)</code>
</li>
</ul>
</li>
<li>Grouping:

<ul>
<li>Named: <code>a \ "group_a"</code> → <code>(a)</code>; the name <code>group_a</code> will be passed to the <code>Regex</code> constructor,  queryable on corresponding <code>Match</code>es</li>
<li>Unnamed: <code>a.g</code> → <code>(a)</code> (a unique group name is generated internally)</li>
<li>Non-capturing: <code>a.ncg</code> → <code>(?:a)</code> or the short syntax <code>a.%</code>
</li>
<li>
<a href="http://www.regular-expressions.info/atomic.html">Atomic</a>: <code>a.ag</code> → <code>(?&gt;a)</code> or the short syntax <code>a.?&gt;</code>
</li>
</ul>
</li>
<li>Back-reference: <code>!g</code> will insert a backreference on group <code>g</code>; e.g. <code>val g = (a|b).g; g - a - !g</code> → <code>(a|b)a\1</code>
</li>
</ul><h3>Constants</h3>

<p>A few "constants" (sub-expressions with no repetitions, capturing groups, or unprotected alternatives) are also pre-defined. Some of them have a UTF-8 Greek symbol alias for conciseness (import <code>REL.Symbols._</code> to use them), uppercase for negation. You can add your own by instancing case class <code>RECst(expr)</code></p>

<ul>
<li>
<code>Epsilon</code> or <code>ε</code> is empty string</li>
<li>
<code>AlphaLower</code> → <code>[a-z]</code>, <code>AlphaUpper</code> → <code>[A-Z]</code>
</li>
<li>
<code>Alpha</code> or <code>α</code> → <code>[a-zA-Z]</code>, <code>NotAlpha</code> or <code>Α</code>* → <code>[^a-zA-Z]</code>
</li>
<li>
<code>LetterLower</code> → <code>\p{Ll}</code>, <code>LetterUpper</code> → <code>\p{Lu}</code> (unicode letters, including)</li>
<li>
<code>Letter</code> or <code>λ</code> → <code>\p{L}</code>, <code>NotLetter</code> or <code>Λ</code> → <code>\P{L}</code>
</li>
<li>
<code>Digit</code> or <code>δ</code> → <code>\d</code>, <code>NotDigit</code> or <code>Δ</code> → <code>\D</code>
</li>
<li>
<code>WhiteSpace</code> or <code>σ</code> → <code>\s</code>, <code>NotWhiteSpace</code> or <code>Σ</code> → <code>\S</code>
</li>
<li>
<code>Word</code> or <code>μ</code> → <code>\w</code> (<code>Alpha</code> or <code>_</code>), <code>NotWord</code> or <code>Μ</code>* → <code>\W</code>
</li>
<li>
<code>WordBoundary</code> or <code>ß</code> → <code>\b</code>, <code>NotWordBoundary</code> or <code>Β</code>* → <code>\B</code>
</li>
<li>
<code>LineBeginning</code> → <code>^</code>, <code>LineEnd</code> → <code>$</code>
</li>
<li>
<code>InputBeginning</code> → <code>\A</code>, <code>InputEnd</code> → <code>\z</code>
</li>
</ul><p><em>* Those are uppercase <code>α</code>/<code>ß</code>/<code>μ</code>, not latin <code>A</code>/<code>B</code>/<code>M</code></em></p>

<h3>Exporting regexes (and other regex flavors)</h3>

<p>The <code>.r</code> method on any <code>RE</code> (sub)tree returns a compiled <code>scala.util.matching.Regex</code>. The <code>.toString</code> method returns the source pattern (equivalent to <code>.r.toString</code>, so the pattern is verified).</p>

<p>For other regex flavors, a translation mechanism is provided: you may subclass <code>Flavor</code>, which exposes a <code>.express(re: RE)</code> method, returning a <code>Tuple[String, List[String]]</code>. The first element is the translated regex string, the second is a list of the group names (in order of appearance). A subclass of <code>Flavor</code> should override <code>.translate(re: RE)</code>, using pattern matching to recursively translate Java regex subtree with matching subtree in the destination regex Flavor. It should call <code>super.translate</code> in the default case to ensure proper recusion.</p>

<p>An example of translation into <a href="http://www.regular-expressions.info/dotnet.html">.NET-flavored regex</a> is provided (<a href="https://github.com/Imaginatio/REL/blob/master/src/main/scala/flavors/DotNETFlavor.scala"><code>DotNETFlavor</code></a>), that</p>

<ul>
<li>translates <code>\w</code> to <code>[a-zA-Z0-9_]</code> (as .NET's <code>\w</code> covers UTF-8 letters including accented, while Java's covers only ASCII)</li>
<li>turns any possessive quantifier into a greedy quantifier wrapped in an atomic group (which is a longer equivalent)</li>
<li>inlines named groups and their references into the .NET <code>(?&lt;name&gt;expr)</code> syntax</li>
</ul><p><a href="http://www.regular-expressions.info">Regular-expression.info</a>'s <a href="http://www.regular-expressions.info/refflavors.html">regex flavors comparison chart</a> may be of use when writing a translation.</p>

<h2>TODO</h2>

<ul>
<li>Core

<ul>
<li>Add <code>RECst.literal(string)</code> (aliased by <code>RE.literal(string)</code>) for auto-escaped literal sequence ; consider <code>RE.apply('symbol)</code> to be another alias</li>
<li>Add missing short notation for non-greedy RepMode in numbered Rep</li>
<li>Add character range support (at DSL level), with inversion (<code>[^...]</code>)</li>
<li>Shortcuts for <code>^</code> and <code>$</code> (beware <code>^</code> is currently used as exactly-N repeater operator)</li>
<li>Consider using <code>'symbols</code> for group names</li>
<li>Add options to easily embed match flags<code>(?idmsux-idmsux)</code> when generating regex</li>
</ul>
</li>
<li>Matchers

<ul>
<li>date: consider extracting incorrect dates (like feb. 31st) with some flag</li>
</ul>
</li>
<li>Utils

<ul>
<li>Generate sample strings that match a regex (e.g. with <a href="http://code.google.com/p/xeger/">Xeger</a>)</li>
<li>Source generation or compiler plugin to enable REL independance [at runtime]</li>
</ul>
</li>
<li>Documentation

<ul>
<li>Document cleaners and extractors</li>
</ul>
</li>
</ul><h2>Known issues</h2>

<p>The string primitives are not parsed, so</p>

<ul>
<li><p>Any group you pass inside those strings won't be taken into account by REL when the final regex is generated. The following groups and back-references will be shifted so the resulting regex will most probably be incorrect.</p></li>
<li><p>You still need to escape your expressions to match regex-significant characters like <code>+</code>, <code>?</code> or <code>(</code>, even in <code>RECst</code> (pending update on this point)</p></li>
</ul><h2>Usage and downloads</h2>

<ul>
<li>download the <a href="https://github.com/Imaginatio/REL">source from github</a> and build the library with SBT</li>
<li>download the <a href="https://github.com/Imaginatio/REL/downloads">latest binary release</a>
</li>
<li>use <a href="https://github.com/Imaginatio/Maven-repository/">our public Maven repository</a>
</li>
</ul><h2>License</h2>

<p>Copyright © 2012 Imaginatio SAS</p>

<p>REL is released under the <a href="http://www.opensource.org/licenses/MIT">MIT License</a></p>

<h2>Authors</h2>

<p>REL was developped by <a href="http://instanceof.me/">Adrien Lavoillotte</a> (<a href="https://github.com/streetpc">@streetpc</a>) and Julien Martin for project <a href="http://splayce.com">Splayce</a> at <a href="http://imaginatio.fr">Imaginatio</a></p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/Imaginatio">Imaginatio</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>