<!DOCTYPE html SYSTEM "about:legacy-compat">
<html>
      <head>
        <title>REL — Cleaners</title>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/blueprint/screen.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/blueprint/grid.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/blueprint/print.css"></link> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"/>
        <![endif]-->
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/pamflet.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/pamflet-print.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/pamflet-grid.css"></link>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/custom.css"></link>
        <script src="js/jquery-1.6.2.min.js"></script>
        <script src="js/jquery.collapse.js"></script>
        <script src="js/pamflet.js"></script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"></link><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <meta charset="utf-8"></meta>
        <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
        
      </head>
      <body>
        <a class="page prev nav" href="Tree+rewriting+%26+Flavors.html">
            <span class="space">&nbsp;</span>
            <span class="flip">❧</span>
          </a><a class="page next nav" href="Limitations+%26+Known+Issues.html">
            <span class="space">&nbsp;</span>
            <span>❧</span>
          </a>
        <div class="container">
          <div class="span-16 prepend-1 append-1">
            <div class="top nav span-16 title">
              <span>REL</span> — Cleaners
            </div>
          </div>
          <div class="span-16 prepend-1 append-1 contents">
            <h1 id="Cleaners">Cleaners</h1><h2 id="Usage">Usage</h2><p><code>Cleaner</code> is really just a case class around a <code>String =&gt; String</code> function. It is aimed to help pre-processing text before matching; its usage is completely optional. It also holds some utility methods to ease composing and instantiation.
</p><p>You create a <code>Cleaner</code> simply by giving it a function:
</p><pre><code class="prettyprint lang-scala">val lineBreakNormalizer = Cleaner(_.replaceAllLiterally(&quot;\r\n&quot;, &quot;\n&quot;);
</code></pre><p>There is a shorthand for regex replacement:
</p><pre><code class="prettyprint lang-scala">val stripMultipleDashes = Cleaner.regexReplaceAll(&quot;--+&quot;.r, &quot;-&quot;)
</code></pre><p>A <code>Cleaner</code> extends <code>Function[String, String]</code>, you use it like any other function, either <code>someCleaner(someString)</code> or <code>someCleaner.apply(someString)</code>.
</p><p>The most readable/familiar form of composing is using unix-like pipes, intuitively applied from left to right:
</p><pre><code class="prettyprint lang-scala">val myCleaner = lineBreakNormalizer | TrimFilter | LowerCaseFilter
</code></pre><p>The pros of heavy cleaning when you can afford it is to match more variations (accents, case sensitivity, double spaces…) with simpler (and possibly faster) regexes. The cons are an upfront performance cost (not necessarily worse than a more complex/permissive regex) and more importantly matching on an altered text, making it harder to locate matches in the original text. This can be addressed by <code>TrackString</code> (covered later in this chapter) but at an additional performance cost.
</p><h2 id="Built-in+Cleaners">Built-in Cleaners</h2><p>In the built-in Cleaners, the naming convention follow these rules of thumb:
</p><ul><li><code>*Normalizer</code> normalizes variations of the same things
</li><li><code>*Cleaner</code> cleans up information that is irrelevant for the task at hand
</li><li><code>*Filter</code> transforms the text to prepare it for matching
</li></ul><p>The bundled Cleaners are:
</p><table>
<colgroup>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:left;">Name</th>
	<th style="text-align:left;">Usage</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;"><code>IdentityCleaner</code></td>
	<td style="text-align:left;">Utility no-op Cleaner</td>
</tr>
<tr>
	<td style="text-align:left;"><code>CamelCaseSplitFilter</code></td>
	<td style="text-align:left;">Split CamelCase words; follows the the form <code>aBc</code> (lower-upper-lower): will split <code>someWords</code> but not <code>iOS</code> nor <code>VitaminC</code></td>
</tr>
<tr>
	<td style="text-align:left;"><code>LowerCaseFilter</code></td>
	<td style="text-align:left;">Transform the text in lowercase; a lowercase-only regexes will often outperform case-insensitive</td>
</tr>
<tr>
	<td style="text-align:left;"><code>LineSeparatorNormalizer</code></td>
	<td style="text-align:left;">Normalize all Unicode line breaks and vertical tabs to ASCII new line <code>U+000A</code> / <code>\n</code></td>
</tr>
<tr>
	<td style="text-align:left;"><code>WhiteSpaceNormalizer</code></td>
	<td style="text-align:left;">Normalize all Unicode spaces and horizontal tabs to ASCII spaces <code>U+0020</code></td>
</tr>
<tr>
	<td style="text-align:left;"><code>WhiteSpaceCleaner</code></td>
	<td style="text-align:left;">Replace multiple instances of regular whitespaces (<code>\s+</code>) by a single space (<strong>strip line breaks</strong>)</td>
</tr>
<tr>
	<td style="text-align:left;"><code>AllWhiteSpaceCleaner</code></td>
	<td style="text-align:left;">Replace multiple instances of all Unicode whitespaces by a single space (<strong>strip line breaks</strong>)</td>
</tr>
<tr>
	<td style="text-align:left;"><code>SingleQuoteNormalizer</code></td>
	<td style="text-align:left;">Normalize frequent Unicode single quote / apostrophe variations (like prime of curved apostrophe) to ASCII straight apostrophe <code>U+0027</code> / <code>&#8217;</code></td>
</tr>
<tr>
	<td style="text-align:left;"><code>DoubleQuoteNormalizer</code></td>
	<td style="text-align:left;">Normalize frequent Unicode double quote variations to ASCII quotation mark <code>U+0022</code> / <code>&quot;</code></td>
</tr>
<tr>
	<td style="text-align:left;"><code>QuoteNormalizer</code></td>
	<td style="text-align:left;">Combines <code>SingleQuoteNormalizer</code> and <code>DoubleQuoteNormalizer</code></td>
</tr>
<tr>
	<td style="text-align:left;"><code>DiacriticCleaner</code></td>
	<td style="text-align:left;">Pseudo ASCII folding, remove <a  href="http://en.wikipedia.org/wiki/Diacritic">diacritical marks</a> (like accents) and some common Unicode variants on Latin characters</td>
</tr>
<tr>
	<td style="text-align:left;"><code>FullwidthNormalizer</code></td>
	<td style="text-align:left;">Normalize <a  href="http://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms">CJK Fullwidth</a> Latin characters to their ASCII equivalents</td>
</tr>
</tbody>
</table>

<h2 id="Create+a+new+Cleaner">Create a new Cleaner</h2><p>You can of course create your own Cleaners.
</p><ul><li><p>If your cleaning operation can fit in a single regex replacement:
</p><pre><code class="prettyprint lang-scala">object HtmlTagCleaner extends Cleaner(
  Cleaner.regexReplaceFirst(&quot;&lt;html[^&gt;]*+&gt;(.*)&lt;/html&gt;&quot;, &quot;$1&quot;))
// or val htmlTagCleaner: Cleaner = Cleaner.regexReplaceFirst(…)
</code></pre></li><li><p>Same for multiple regex replacement:
</p><pre><code class="prettyprint lang-scala">object HtmlCommentsCleaner extends Cleaner(
  Cleaner.regexReplaceAll(&quot;&lt;!--(.*)--&gt;&quot;, &quot;&quot;))
</code></pre></li><li>Otherwise, you can simply instantiate a Cleaner with your own <code>String =&gt; String</code> transformation.
</li></ul><h2 id="TrackStrings">TrackStrings</h2><p>TrackStrings are strings that can, to a certain extent, keep track of the shifts in positions. You pass Strings through Cleaners / regex replacement and remain able to get the position (or the best estimated range) in the original string of a [group of] character[s] that have moved in the resulting string:
</p><pre><code class="prettyprint lang-scala">import fr.splayce.rel.util.TrackString
val ts = TrackString(&quot;Test - OK - passed&quot;)
  .replaceAll(&quot; - &quot;.r, &quot; &quot;)  // &quot;Test OK passed&quot;
ts.srcPos(5, 7)   // Interval [7,9) was the original position of &quot;OK&quot;
ts.srcPos(8, 14)  // Interval [12,18) was the original position of &quot;passed&quot;
</code></pre><p>And Cleaners support TrackStrings, so this allows you to:
</p><ul><li>Clean an input string
</li><li>Match it against a simplified regex (thanks to the cleaning)
</li><li>Know the position of the match <em>in the original uncleaned string</em> (e.g. for highlighting matches, performing replacements, etc.)
</li></ul><pre><code class="prettyprint lang-scala">import fr.splayce.rel.cleaners.CamelCaseSplitFilter
val os = &quot;MySuperClass&quot;
val ts = CamelCaseSplitFilter(TrackString(os))  // &quot;My Super Class&quot;
val m = &quot;Super&quot;.r.findFirstMatchIn(ts.toString).get
val op = ts.srcPos(m.start, m.end)  // Interval [2,7)
val highlight = os.substring(0, op.start)
  + &quot;&lt;strong&gt;&quot; + os.substring(op.start, op.end) + &quot;&lt;/strong&gt;&quot;
  + os.substring(op.end)
  // &quot;My&lt;strong&gt;Super&lt;/strong&gt;Class&quot;
</code></pre><p>Please note that, while Cleaners made with <code>Cleaner.regexReplaceFirst</code> and <code>Cleaner.regexReplaceAll</code> automatically support position tracking, you will have to implement <code>apply: TrackString =&gt; TrackString</code> if you implement your own cleaners, e.g. by calling <code>TrackString.edit</code> (see the API doc). Otherwise, the TrackString will see your string transformation as one big replacement – i.e. it will tell you that the original position of any character is somewhere between the beginning and the end of your original string, which admittedly isn’t of much help.</p><div class="bottom nav">
                        <em>Next Page</em>
                        <span class="arrow">❧</span>
                        <a href="Limitations+%26+Known+Issues.html"> Limitations &amp; Known Issues </a>
                      </div><div class="tocwrapper show">
      <a class="tochead nav" style="display: none" href="#toc">❦</a>
      <a name="toc"></a>
      <h4 class="toctitle">Contents</h4>
      <div class="tocbody">
      <div><a href="index.html">REL</a></div><ol class="toc"> <li><div><a href="DSL+Syntax.html">DSL Syntax</a></div></li><li><div><a href="Extractors.html">Extractors</a></div></li><li><div><a href="Matchers.html">Matchers</a></div></li><li><div><a href="Tree+rewriting+%26+Flavors.html">Tree rewriting &amp; Flavors</a></div></li><li><div class="current">Cleaners</div></li><li><div><a href="Limitations+%26+Known+Issues.html">Limitations &amp; Known Issues</a></div></li><li class="generated"><div><a href="Contents+in+Depth.html">Contents in Depth</a></div></li><li class="generated"><div><a href="Combined+Pages.html">Combined Pages</a></div></li> </ol></div></div>
          </div>
        </div>
        
      </body>
    </html>